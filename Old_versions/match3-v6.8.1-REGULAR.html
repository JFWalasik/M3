<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Match-3 Game v6.8.1</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
// Destructure React hooks from global React object
const { useState, useEffect, useRef, useCallback } = React;

// =============================================================================
// MATCH-3 GAME v6.8.1 - CANVAS EDITION (Production Build)
// Performance-optimized with HTML5 Canvas rendering
// 10x12 grid, R1 Sunflower, Blue Jewel, Green Clover (board v7 designs)
// Production React for GitHub Pages deployment
// =============================================================================

// Game Constants
const ROWS = 12;
const COLS = 10;
const TILE_SIZE = 50;
const TILE_GAP = 4;
const TILE_TYPES = 6;

// Difficulty Constants  
const MIN_MOVES = 18;
const MAX_MOVES = 24;
const BASE_TARGET = 5000;
const TARGET_VARIANCE = 1500;

// Scoring Constants
const WIN_BONUS_PER_MOVE = 100;
const DIFFICULTY_INCREMENT_MIN = 200;
const DIFFICULTY_INCREMENT_MAX = 500;

// Animation Constants
const ANIMATION_SPEED = 0.15; // Higher = faster (0-1)
const DROP_SPEED = 0.12;
const MATCH_FADE_SPEED = 0.08;

// Tile Colors and Drawing Functions
const TILE_COLORS = [
  { name: 'hypocycloid', primary: '#E53935', light: '#FFCDD2', dark: '#B71C1C', accent: '#FF5252' },
  { name: 'diamond', primary: '#1E88E5', light: '#90CAF9', dark: '#0D47A1', accent: '#42A5F5' },
  { name: 'clover', primary: '#4CAF50', light: '#81C784', dark: '#2E7D32', accent: '#66BB6A' },
  { name: 'star', primary: '#FFD700', light: '#FFF9C4', dark: '#FF8F00', accent: '#FFD54F' },
  { name: 'candy', primary: '#8E24AA', light: '#E1BEE7', dark: '#6A1B9A', accent: '#AB47BC' },
  { name: 'sun', primary: '#FF9800', light: '#FFCC80', dark: '#BF360C', accent: '#FFB74D' }
];

// Canvas Tile Drawing Functions
const drawTile = (ctx, x, y, size, tileType, options = {}) => {
  const { isSelected, isMatched, isSpecial, isPending, opacity = 1, scale = 1 } = options;
  const color = TILE_COLORS[tileType];
  
  ctx.save();
  ctx.globalAlpha = opacity;
  
  // Center and scale
  const centerX = x + size / 2;
  const centerY = y + size / 2;
  ctx.translate(centerX, centerY);
  ctx.scale(scale, scale);
  ctx.translate(-centerX, -centerY);
  
  // Draw shape based on type
  switch (tileType) {
    case 0: drawHypocycloid(ctx, x, y, size, color); break;
    case 1: drawDiamond(ctx, x, y, size, color); break;
    case 2: drawClover(ctx, x, y, size, color); break;
    case 3: drawStar(ctx, x, y, size, color); break;
    case 4: drawCandy(ctx, x, y, size, color); break;
    case 5: drawSun(ctx, x, y, size, color); break;
  }
  
  // Selection/special effects
  if (isSelected) {
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 3;
    ctx.strokeRect(x + 2, y + 2, size - 4, size - 4);
    ctx.shadowColor = 'rgba(255,255,255,0.9)';
    ctx.shadowBlur = 15;
  }
  
  if (isPending) {
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 3;
    ctx.strokeRect(x + 2, y + 2, size - 4, size - 4);
  }
  
  if (isSpecial) {
    ctx.strokeStyle = 'gold';
    ctx.lineWidth = 3;
    ctx.strokeRect(x + 2, y + 2, size - 4, size - 4);
  }
  
  ctx.restore();
};

// Hypocycloid (Red) - 4-pointed star shape
const drawHypocycloid = (ctx, x, y, size, color) => {
  const cx = x + size / 2;
  const cy = y + size / 2;
  const r = size * 0.45;
  
  // Create gradient
  const gradient = ctx.createRadialGradient(cx - r * 0.3, cy - r * 0.3, 0, cx, cy, r);
  gradient.addColorStop(0, color.light);
  gradient.addColorStop(0.3, color.accent);
  gradient.addColorStop(0.7, color.primary);
  gradient.addColorStop(1, color.dark);
  
  ctx.beginPath();
  // 4-pointed astroid shape
  ctx.moveTo(cx, cy - r);
  ctx.quadraticCurveTo(cx + r * 0.2, cy - r * 0.2, cx + r, cy);
  ctx.quadraticCurveTo(cx + r * 0.2, cy + r * 0.2, cx, cy + r);
  ctx.quadraticCurveTo(cx - r * 0.2, cy + r * 0.2, cx - r, cy);
  ctx.quadraticCurveTo(cx - r * 0.2, cy - r * 0.2, cx, cy - r);
  ctx.closePath();
  
  ctx.fillStyle = gradient;
  ctx.fill();
  ctx.strokeStyle = color.dark;
  ctx.lineWidth = 1;
  ctx.stroke();
  
  // Highlight
  ctx.beginPath();
  ctx.ellipse(cx - r * 0.25, cy - r * 0.25, r * 0.2, r * 0.15, -0.5, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.fill();
};

// Diamond (Blue) - Bejeweled style gem
// Blue Jewel - Faceted cut gem (from board-preview-v7)
const drawDiamond = (ctx, x, y, size, color) => {
  const scale = size / 40; // Board SVG uses 40x40 viewBox
  
  // Gradient for main body (crown)
  const gradient1 = ctx.createLinearGradient(x, y, x + size, y + size);
  gradient1.addColorStop(0, '#42A5F5');
  gradient1.addColorStop(0.4, '#1E88E5');
  gradient1.addColorStop(1, '#0D47A1');
  
  // Gradient for pavilion (bottom)
  const gradient2 = ctx.createLinearGradient(x, y + size * 0.5, x, y + size);
  gradient2.addColorStop(0, '#64B5F6');
  gradient2.addColorStop(1, '#1565C0');
  
  // Crown (top trapezoid): points="8,12 32,12 38,20 2,20"
  ctx.beginPath();
  ctx.moveTo(x + 8 * scale, y + 12 * scale);
  ctx.lineTo(x + 32 * scale, y + 12 * scale);
  ctx.lineTo(x + 38 * scale, y + 20 * scale);
  ctx.lineTo(x + 2 * scale, y + 20 * scale);
  ctx.closePath();
  ctx.fillStyle = gradient1;
  ctx.fill();
  
  // Table facet (top cap): points="12,12 28,12 26,8 14,8"
  ctx.beginPath();
  ctx.moveTo(x + 12 * scale, y + 12 * scale);
  ctx.lineTo(x + 28 * scale, y + 12 * scale);
  ctx.lineTo(x + 26 * scale, y + 8 * scale);
  ctx.lineTo(x + 14 * scale, y + 8 * scale);
  ctx.closePath();
  ctx.fillStyle = '#90CAF9';
  ctx.fill();
  
  // Pavilion (bottom triangle): points="2,20 38,20 20,38"
  ctx.beginPath();
  ctx.moveTo(x + 2 * scale, y + 20 * scale);
  ctx.lineTo(x + 38 * scale, y + 20 * scale);
  ctx.lineTo(x + 20 * scale, y + 38 * scale);
  ctx.closePath();
  ctx.fillStyle = gradient2;
  ctx.fill();
  
  // Highlight: points="14,10 20,10 18,14 14,14"
  ctx.beginPath();
  ctx.moveTo(x + 14 * scale, y + 10 * scale);
  ctx.lineTo(x + 20 * scale, y + 10 * scale);
  ctx.lineTo(x + 18 * scale, y + 14 * scale);
  ctx.lineTo(x + 14 * scale, y + 14 * scale);
  ctx.closePath();
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.fill();
};

// Green Clover - 3 heart leaves (from board-preview-v7)
const drawClover = (ctx, x, y, size, color) => {
  const scale = size / 40; // Board SVG uses 40x40 viewBox
  
  // Gradient for leaves
  const gradient = ctx.createRadialGradient(
    x + 14 * scale, y + 14 * scale, 0,
    x + 20 * scale, y + 20 * scale, 26 * scale
  );
  gradient.addColorStop(0, '#81C784');
  gradient.addColorStop(0.4, '#4CAF50');
  gradient.addColorStop(1, '#2E7D32');
  
  ctx.fillStyle = gradient;
  
  // Top heart leaf
  ctx.beginPath();
  ctx.moveTo(x + 20 * scale, y + 5 * scale);
  ctx.bezierCurveTo(
    x + 18 * scale, y + 3 * scale,
    x + 15 * scale, y + 3 * scale,
    x + 13 * scale, y + 5 * scale
  );
  ctx.bezierCurveTo(
    x + 11 * scale, y + 7 * scale,
    x + 11 * scale, y + 10 * scale,
    x + 13 * scale, y + 13 * scale
  );
  ctx.lineTo(x + 20 * scale, y + 20 * scale);
  ctx.lineTo(x + 27 * scale, y + 13 * scale);
  ctx.bezierCurveTo(
    x + 29 * scale, y + 10 * scale,
    x + 29 * scale, y + 7 * scale,
    x + 27 * scale, y + 5 * scale
  );
  ctx.bezierCurveTo(
    x + 25 * scale, y + 3 * scale,
    x + 22 * scale, y + 3 * scale,
    x + 20 * scale, y + 5 * scale
  );
  ctx.closePath();
  ctx.fill();
  
  // Left heart leaf
  ctx.beginPath();
  ctx.moveTo(x + 5 * scale, y + 20 * scale);
  ctx.bezierCurveTo(
    x + 3 * scale, y + 18 * scale,
    x + 3 * scale, y + 15 * scale,
    x + 5 * scale, y + 13 * scale
  );
  ctx.bezierCurveTo(
    x + 7 * scale, y + 11 * scale,
    x + 10 * scale, y + 11 * scale,
    x + 13 * scale, y + 13 * scale
  );
  ctx.lineTo(x + 20 * scale, y + 20 * scale);
  ctx.lineTo(x + 13 * scale, y + 27 * scale);
  ctx.bezierCurveTo(
    x + 10 * scale, y + 29 * scale,
    x + 7 * scale, y + 29 * scale,
    x + 5 * scale, y + 27 * scale
  );
  ctx.bezierCurveTo(
    x + 3 * scale, y + 25 * scale,
    x + 3 * scale, y + 22 * scale,
    x + 5 * scale, y + 20 * scale
  );
  ctx.closePath();
  ctx.fill();
  
  // Right heart leaf
  ctx.beginPath();
  ctx.moveTo(x + 35 * scale, y + 20 * scale);
  ctx.bezierCurveTo(
    x + 37 * scale, y + 18 * scale,
    x + 37 * scale, y + 15 * scale,
    x + 35 * scale, y + 13 * scale
  );
  ctx.bezierCurveTo(
    x + 33 * scale, y + 11 * scale,
    x + 30 * scale, y + 11 * scale,
    x + 27 * scale, y + 13 * scale
  );
  ctx.lineTo(x + 20 * scale, y + 20 * scale);
  ctx.lineTo(x + 27 * scale, y + 27 * scale);
  ctx.bezierCurveTo(
    x + 30 * scale, y + 29 * scale,
    x + 33 * scale, y + 29 * scale,
    x + 35 * scale, y + 27 * scale
  );
  ctx.bezierCurveTo(
    x + 37 * scale, y + 25 * scale,
    x + 37 * scale, y + 22 * scale,
    x + 35 * scale, y + 20 * scale
  );
  ctx.closePath();
  ctx.fill();
  
  // Stem
  ctx.beginPath();
  ctx.moveTo(x + 20 * scale, y + 20 * scale);
  ctx.lineTo(x + 20 * scale, y + 32 * scale);
  ctx.strokeStyle = '#2E7D32';
  ctx.lineWidth = 3 * scale;
  ctx.lineCap = 'round';
  ctx.stroke();
  
  // Highlight on top leaf
  ctx.beginPath();
  ctx.ellipse(x + 17 * scale, y + 9 * scale, 2 * scale, 1.5 * scale, -0.3, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.fill();
};

// Star (Gold) - 5-pointed star
const drawStar = (ctx, x, y, size, color) => {
  const cx = x + size / 2;
  const cy = y + size / 2;
  const outerR = size * 0.45;
  const innerR = size * 0.2;
  
  // Gradient
  const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
  gradient.addColorStop(0, color.light);
  gradient.addColorStop(0.3, color.accent);
  gradient.addColorStop(0.7, color.primary);
  gradient.addColorStop(1, color.dark);
  
  ctx.beginPath();
  for (let i = 0; i < 5; i++) {
    const outerAngle = (i * 72 - 90) * Math.PI / 180;
    const innerAngle = ((i * 72) + 36 - 90) * Math.PI / 180;
    
    if (i === 0) {
      ctx.moveTo(cx + outerR * Math.cos(outerAngle), cy + outerR * Math.sin(outerAngle));
    } else {
      ctx.lineTo(cx + outerR * Math.cos(outerAngle), cy + outerR * Math.sin(outerAngle));
    }
    ctx.lineTo(cx + innerR * Math.cos(innerAngle), cy + innerR * Math.sin(innerAngle));
  }
  ctx.closePath();
  
  ctx.fillStyle = gradient;
  ctx.fill();
  ctx.strokeStyle = '#E65100';
  ctx.lineWidth = 1;
  ctx.stroke();
  
  // Inner highlight star
  ctx.beginPath();
  const highlightR = outerR * 0.5;
  const highlightInnerR = innerR * 0.6;
  for (let i = 0; i < 5; i++) {
    const outerAngle = (i * 72 - 90) * Math.PI / 180;
    const innerAngle = ((i * 72) + 36 - 90) * Math.PI / 180;
    if (i === 0) {
      ctx.moveTo(cx + highlightR * Math.cos(outerAngle), cy + highlightR * Math.sin(outerAngle));
    } else {
      ctx.lineTo(cx + highlightR * Math.cos(outerAngle), cy + highlightR * Math.sin(outerAngle));
    }
    ctx.lineTo(cx + highlightInnerR * Math.cos(innerAngle), cy + highlightInnerR * Math.sin(innerAngle));
  }
  ctx.closePath();
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.fill();
};

// Candy (Purple) - Jelly bean shape
const drawCandy = (ctx, x, y, size, color) => {
  const cx = x + size / 2;
  const cy = y + size / 2;
  const rx = size * 0.4;
  const ry = size * 0.3;
  
  // Gradient
  const gradient = ctx.createRadialGradient(cx - rx * 0.3, cy - ry * 0.3, 0, cx, cy, rx * 1.2);
  gradient.addColorStop(0, color.light);
  gradient.addColorStop(0.4, color.accent);
  gradient.addColorStop(1, color.dark);
  
  ctx.beginPath();
  ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
  ctx.fillStyle = gradient;
  ctx.fill();
  ctx.strokeStyle = color.dark;
  ctx.lineWidth = 1;
  ctx.stroke();
  
  // Highlight
  ctx.beginPath();
  ctx.ellipse(cx - rx * 0.35, cy - ry * 0.3, rx * 0.35, ry * 0.3, -0.2, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.fill();
  
  // Shadow
  ctx.beginPath();
  ctx.ellipse(cx + rx * 0.25, cy + ry * 0.25, rx * 0.25, ry * 0.15, 0.2, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.fill();
};

// Sun (Orange) - R1 Teardrop Warm Orange Sunflower
const drawSun = (ctx, x, y, size, color) => {
  const cx = x + size / 2;
  const cy = y + size / 2;
  const coreR = size * 0.22;
  
  // Center gradient (warm orange)
  const centerGradient = ctx.createRadialGradient(cx - coreR * 0.3, cy - coreR * 0.3, 0, cx, cy, coreR * 1.1);
  centerGradient.addColorStop(0, '#FFCC80');
  centerGradient.addColorStop(0.5, '#FF9800');
  centerGradient.addColorStop(1, '#E65100');
  
  // Petal gradient (warm orange)
  const petalGradient = ctx.createLinearGradient(cx, cy - size * 0.45, cx, cy);
  petalGradient.addColorStop(0, '#FFB74D');
  petalGradient.addColorStop(0.5, '#FF9800');
  petalGradient.addColorStop(1, '#BF360C');
  
  // Draw 12 teardrop petals
  ctx.fillStyle = petalGradient;
  for (let i = 0; i < 12; i++) {
    const angle = (i * 30) * Math.PI / 180;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);
    ctx.beginPath();
    // Teardrop shape: pointed at top, rounded at bottom
    ctx.moveTo(0, -size * 0.44); // Top point
    ctx.quadraticCurveTo(size * 0.1, -size * 0.32, size * 0.06, -size * 0.24); // Right curve
    ctx.quadraticCurveTo(0, -size * 0.18, -size * 0.06, -size * 0.24); // Bottom curve
    ctx.quadraticCurveTo(-size * 0.1, -size * 0.32, 0, -size * 0.44); // Left curve back to top
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
  
  // Center circle
  ctx.beginPath();
  ctx.arc(cx, cy, coreR, 0, Math.PI * 2);
  ctx.fillStyle = centerGradient;
  ctx.fill();
  ctx.strokeStyle = '#BF360C';
  ctx.lineWidth = 0.5;
  ctx.stroke();
  
  // Highlight on center
  ctx.beginPath();
  ctx.ellipse(cx - coreR * 0.3, cy - coreR * 0.25, coreR * 0.35, coreR * 0.25, -0.3, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.fill();
};

// Draw special tile icon
const drawSpecialIcon = (ctx, x, y, size, specialType) => {
  ctx.font = '14px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = 'rgba(0,0,0,0.8)';
  ctx.shadowBlur = 4;
  
  const icons = {
    'line': 'âš¡',
    'bomb': 'ðŸ’£',
    'cross': 'âœ¨',
    'supernova': 'ðŸŒŒ',
    'hypernova': 'ðŸŒ '
  };
  
  ctx.fillText(icons[specialType] || 'âœ¨', x + size / 2, y + size / 2);
  ctx.shadowBlur = 0;
};

// =============================================================================
// GAME LOGIC (preserved from v5.0)
// =============================================================================

const initializeGrid = () => {
  const grid = [];
  for (let row = 0; row < ROWS; row++) {
    grid[row] = [];
    for (let col = 0; col < COLS; col++) {
      let type;
      let attempts = 0;
      do {
        type = Math.floor(Math.random() * TILE_TYPES);
        attempts++;
        if (attempts > 50) break;
      } while (
        (col >= 2 && grid[row][col - 1]?.type === type && grid[row][col - 2]?.type === type) ||
        (row >= 2 && grid[row - 1]?.[col]?.type === type && grid[row - 2]?.[col]?.type === type)
      );
      
      grid[row][col] = {
        type,
        id: `${row}-${col}-${Date.now()}-${Math.random()}`,
        special: null,
        isNew: false,
        // Animation properties
        animX: col * (TILE_SIZE + TILE_GAP),
        animY: row * (TILE_SIZE + TILE_GAP),
        targetX: col * (TILE_SIZE + TILE_GAP),
        targetY: row * (TILE_SIZE + TILE_GAP),
        opacity: 1,
        scale: 1
      };
    }
  }
  return grid;
};

const hasValidMoves = (grid) => {
  for (let row = 0; row < ROWS; row++) {
    for (let col = 0; col < COLS; col++) {
      if (col < COLS - 1) {
        const testGrid = grid.map(r => r.map(t => t ? { ...t } : null));
        [testGrid[row][col], testGrid[row][col + 1]] = [testGrid[row][col + 1], testGrid[row][col]];
        if (findMatchesSimple(testGrid).length > 0) return true;
      }
      if (row < ROWS - 1) {
        const testGrid = grid.map(r => r.map(t => t ? { ...t } : null));
        [testGrid[row][col], testGrid[row + 1][col]] = [testGrid[row + 1][col], testGrid[row][col]];
        if (findMatchesSimple(testGrid).length > 0) return true;
      }
    }
  }
  return false;
};

const findMatchesSimple = (grid) => {
  const matches = [];
  
  for (let row = 0; row < ROWS; row++) {
    for (let col = 0; col < COLS - 2; col++) {
      if (grid[row][col] && grid[row][col + 1] && grid[row][col + 2] &&
          grid[row][col].type === grid[row][col + 1].type &&
          grid[row][col].type === grid[row][col + 2].type) {
        matches.push({ row, col });
      }
    }
  }
  
  for (let row = 0; row < ROWS - 2; row++) {
    for (let col = 0; col < COLS; col++) {
      if (grid[row][col] && grid[row + 1][col] && grid[row + 2][col] &&
          grid[row][col].type === grid[row + 1][col].type &&
          grid[row][col].type === grid[row + 2][col].type) {
        matches.push({ row, col });
      }
    }
  }
  
  return matches;
};

const calculateUnusedSpecialsBonus = (grid) => {
  let bonus = 0;
  const specials = { line: 0, bomb: 0, cross: 0, supernova: 0, hypernova: 0 };
  
  grid.forEach(row => {
    row.forEach(tile => {
      if (tile?.special) {
        specials[tile.special]++;
        switch (tile.special) {
          case 'line': bonus += 100; break;
          case 'bomb': bonus += 150; break;
          case 'cross': bonus += 200; break;
          case 'supernova': bonus += 300; break;
          case 'hypernova': bonus += 500; break;
        }
      }
    });
  });
  
  return { bonus, specials };
};

// =============================================================================
// MAIN COMPONENT
// =============================================================================

const Match3Game = () => {
  // Game state
  const [grid, setGrid] = useState(initializeGrid);
  const [selectedTile, setSelectedTile] = useState(null);
  const [score, setScore] = useState(0);
  const [moves, setMoves] = useState(() => MIN_MOVES + Math.floor(Math.random() * (MAX_MOVES - MIN_MOVES + 1)));
  const [gameState, setGameState] = useState('playing');
  const [isAnimating, setIsAnimating] = useState(false);
  const [levelTarget, setLevelTarget] = useState(() => {
    const rawTarget = BASE_TARGET + Math.floor(Math.random() * TARGET_VARIANCE);
    return Math.round(rawTarget / 100) * 100;
  });
  const [difficultyBonus, setDifficultyBonus] = useState(0);
  const [highScore, setHighScore] = useState(() => {
    const stored = localStorage.getItem('match3_highScore');
    return stored ? parseInt(stored, 10) : 0;
  });
  const [combo, setCombo] = useState(0);
  const [lastCombo, setLastCombo] = useState(0);
  const [maxComboReached, setMaxComboReached] = useState(0);
  const [scorePopups, setScorePopups] = useState([]);
  const [showNoMoves, setShowNoMoves] = useState(false);
  const [pendingSpecials, setPendingSpecials] = useState([]);
  const [targetReached, setTargetReached] = useState(false);
  const [matchedTiles, setMatchedTiles] = useState([]);
  const [dragStart, setDragStart] = useState(null); // For drag/swipe support
  const [turnComplete, setTurnComplete] = useState(true); // Track when turn scoring is fully settled
  
  // Persistent stats
  const [allTimeHighCombo, setAllTimeHighCombo] = useState(() => {
    const stored = localStorage.getItem('match3_highCombo');
    return stored ? parseInt(stored, 10) : 0;
  });
  const [allTimeHighTurnScore, setAllTimeHighTurnScore] = useState(() => {
    const stored = localStorage.getItem('match3_highTurnScore');
    return stored ? parseInt(stored, 10) : 0;
  });
  const [currentTurnScore, setCurrentTurnScore] = useState(0);
  const [specialBonusMultiplier, setSpecialBonusMultiplier] = useState(0);
  
  // Canvas ref
  const canvasRef = useRef(null);
  const animationFrameRef = useRef(null);
  
  // v6.8: Ref to track latest score (avoids stale closure in game end check)
  const scoreRef = useRef(0);
  useEffect(() => { scoreRef.current = score; }, [score]);
  
  // Board dimensions
  const boardWidth = COLS * TILE_SIZE + (COLS - 1) * TILE_GAP;
  const boardHeight = ROWS * TILE_SIZE + (ROWS - 1) * TILE_GAP;
  
  // Save stats to localStorage
  useEffect(() => {
    localStorage.setItem('match3_highCombo', allTimeHighCombo.toString());
  }, [allTimeHighCombo]);
  
  useEffect(() => {
    localStorage.setItem('match3_highTurnScore', allTimeHighTurnScore.toString());
  }, [allTimeHighTurnScore]);
  
  useEffect(() => {
    localStorage.setItem('match3_highScore', highScore.toString());
  }, [highScore]);
  
  // Update all-time stats when turn ends
  useEffect(() => {
    if (!isAnimating && gameState === 'playing') {
      if (maxComboReached > allTimeHighCombo) {
        setAllTimeHighCombo(maxComboReached);
      }
      if (currentTurnScore > allTimeHighTurnScore) {
        setAllTimeHighTurnScore(currentTurnScore);
      }
    }
  }, [isAnimating, gameState, maxComboReached, currentTurnScore, allTimeHighCombo, allTimeHighTurnScore]);
  
  // Check win condition
  useEffect(() => {
    if (score >= levelTarget && gameState === 'playing' && !targetReached) {
      setTargetReached(true);
    }
  }, [score, levelTarget, gameState, targetReached]);
  
  // Game end logic - FIXED in v6.8: Use ref for latest score, add delay for state to settle
  useEffect(() => {
    // Don't check until turn is fully complete (all scoring settled)
    if (!turnComplete || isAnimating || combo > 0 || pendingSpecials.length > 0) return;
    if (gameState !== 'playing') return;
    
    // v6.8: Add a small delay to ensure all React state updates have propagated
    const checkTimer = setTimeout(() => {
      // Use scoreRef.current to get the absolute latest score value
      const currentScore = scoreRef.current;
      const hasWon = targetReached || currentScore >= levelTarget;
      
      console.log('Game end check:', { currentScore, levelTarget, hasWon, moves, targetReached });
      
      if (hasWon) {
        const moveBonus = Math.max(0, moves) * WIN_BONUS_PER_MOVE;
        const { bonus: specialsBonus } = calculateUnusedSpecialsBonus(grid);
        const totalBonus = moveBonus + specialsBonus;
        
        setScore(prev => prev + totalBonus);
        
        const difficultyIncrease = DIFFICULTY_INCREMENT_MIN + 
          Math.floor(Math.random() * (DIFFICULTY_INCREMENT_MAX - DIFFICULTY_INCREMENT_MIN + 1));
        setDifficultyBonus(prev => prev + difficultyIncrease);
        
        if (currentScore + totalBonus > highScore) setHighScore(currentScore + totalBonus);
        if (!targetReached) setTargetReached(true);
        
        setGameState('won');
        return;
      }
      
      if (moves <= 0 && !hasWon) {
        const { bonus: specialsBonus } = calculateUnusedSpecialsBonus(grid);
        setScore(prev => prev + specialsBonus);
        if (currentScore + specialsBonus > highScore) setHighScore(currentScore + specialsBonus);
        setDifficultyBonus(0);
        setGameState('gameover');
      }
    }, 150); // 150ms delay to ensure state has settled
    
    return () => clearTimeout(checkTimer);
  }, [moves, gameState, levelTarget, highScore, isAnimating, combo, targetReached, pendingSpecials.length, grid, turnComplete]);
  
  // Score popup cleanup
  useEffect(() => {
    if (scorePopups.length > 0) {
      const timer = setTimeout(() => setScorePopups(prev => prev.slice(1)), 2000);
      return () => clearTimeout(timer);
    }
  }, [scorePopups]);
  
  // Animation failsafe
  useEffect(() => {
    if (isAnimating) {
      const failsafe = setTimeout(() => {
        setIsAnimating(false);
        setPendingSpecials([]);
      }, 8000);
      return () => clearTimeout(failsafe);
    }
  }, [isAnimating]);
  
  // =============================================================================
  // CANVAS RENDERING
  // =============================================================================
  
  const renderCanvas = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Scale for retina displays
    ctx.save();
    ctx.scale(dpr, dpr);
    
    // Draw background
    const bgGradient = ctx.createLinearGradient(0, 0, boardWidth, boardHeight);
    bgGradient.addColorStop(0, '#f5f7fa');
    bgGradient.addColorStop(1, '#c3cfe2');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, boardWidth, boardHeight);
    
    // Draw tiles
    grid.forEach((row, rowIndex) => {
      row.forEach((tile, colIndex) => {
        if (!tile) return;
        
        const isSelected = selectedTile?.row === rowIndex && selectedTile?.col === colIndex;
        const isMatched = matchedTiles.some(m => m.row === rowIndex && m.col === colIndex);
        const isPending = pendingSpecials.some(p => p.row === rowIndex && p.col === colIndex);
        
        // Calculate animated position
        const targetX = colIndex * (TILE_SIZE + TILE_GAP);
        const targetY = rowIndex * (TILE_SIZE + TILE_GAP);
        
        // Smooth animation
        if (tile.animX !== undefined) {
          tile.animX += (targetX - tile.animX) * ANIMATION_SPEED;
          tile.animY += (targetY - tile.animY) * ANIMATION_SPEED;
        } else {
          tile.animX = targetX;
          tile.animY = targetY;
        }
        
        // Calculate scale for matched tiles
        let scale = 1;
        let opacity = 1;
        if (isMatched) {
          scale = 1.1;
          opacity = 0.7;
        } else if (isSelected) {
          scale = 1.1;
        } else if (isPending) {
          scale = 1.05;
        }
        
        // Draw the tile
        drawTile(ctx, tile.animX, tile.animY, TILE_SIZE, tile.type, {
          isSelected,
          isMatched,
          isSpecial: tile.special !== null,
          isPending,
          opacity,
          scale
        });
        
        // Draw special icon if applicable
        if (tile.special) {
          drawSpecialIcon(ctx, tile.animX, tile.animY, TILE_SIZE, tile.special);
        }
      });
    });
    
    ctx.restore();
    
    // Continue animation loop
    animationFrameRef.current = requestAnimationFrame(renderCanvas);
  }, [grid, selectedTile, matchedTiles, pendingSpecials, boardWidth, boardHeight]);
  
  // Start/stop animation loop
  useEffect(() => {
    animationFrameRef.current = requestAnimationFrame(renderCanvas);
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [renderCanvas]);
  
  // Setup canvas
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const dpr = window.devicePixelRatio || 1;
    canvas.width = boardWidth * dpr;
    canvas.height = boardHeight * dpr;
    canvas.style.width = `${boardWidth}px`;
    canvas.style.height = `${boardHeight}px`;
  }, [boardWidth, boardHeight]);
  
  // =============================================================================
  // INPUT HANDLING
  // =============================================================================
  
  const handleCanvasClick = (e) => {
    if (isAnimating || gameState !== 'playing') return;
    
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const col = Math.floor(x / (TILE_SIZE + TILE_GAP));
    const row = Math.floor(y / (TILE_SIZE + TILE_GAP));
    
    if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return;
    
    handleTileClick(row, col);
  };
  
  // Drag/Swipe handlers for touch and mouse
  const getEventCoords = (e) => {
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    if (e.touches && e.touches[0]) {
      return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
    }
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  };
  
  const handleDragStart = (e) => {
    if (isAnimating || gameState !== 'playing') return;
    e.preventDefault();
    
    const { x, y } = getEventCoords(e);
    const col = Math.floor(x / (TILE_SIZE + TILE_GAP));
    const row = Math.floor(y / (TILE_SIZE + TILE_GAP));
    
    if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
      setDragStart({ row, col, x, y });
      setSelectedTile({ row, col });
    }
  };
  
  const handleDragMove = (e) => {
    if (!dragStart || isAnimating || gameState !== 'playing') return;
    e.preventDefault();
    
    const { x, y } = getEventCoords(e);
    const dx = x - dragStart.x;
    const dy = y - dragStart.y;
    const threshold = TILE_SIZE * 0.4; // 40% of tile size
    
    let targetRow = dragStart.row;
    let targetCol = dragStart.col;
    
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > threshold) targetCol = dragStart.col + 1;
      else if (dx < -threshold) targetCol = dragStart.col - 1;
    } else {
      if (dy > threshold) targetRow = dragStart.row + 1;
      else if (dy < -threshold) targetRow = dragStart.row - 1;
    }
    
    if ((targetRow !== dragStart.row || targetCol !== dragStart.col) &&
        targetRow >= 0 && targetRow < ROWS && targetCol >= 0 && targetCol < COLS) {
      setDragStart(null);
      setSelectedTile(null);
      attemptSwap(dragStart.row, dragStart.col, targetRow, targetCol);
    }
  };
  
  const handleDragEnd = () => {
    setDragStart(null);
  };
  
  const handleTileClick = (row, col) => {
    if (isAnimating || gameState !== 'playing') return;
    
    if (!selectedTile) {
      setSelectedTile({ row, col });
      return;
    }
    
    const rowDiff = Math.abs(selectedTile.row - row);
    const colDiff = Math.abs(selectedTile.col - col);
    
    if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
      attemptSwap(selectedTile.row, selectedTile.col, row, col);
    } else {
      setSelectedTile({ row, col });
    }
  };
  
  const attemptSwap = (row1, col1, row2, col2) => {
    setIsAnimating(true);
    setSelectedTile(null);
    setCurrentTurnScore(0);
    setTurnComplete(false); // v6.7: Mark turn as in-progress
    
    const newGrid = grid.map(r => r.map(t => t ? { ...t } : null));
    
    // Check if BOTH tiles are special BEFORE swapping
    const tile1Special = newGrid[row1][col1]?.special;
    const tile2Special = newGrid[row2][col2]?.special;
    
    // Perform the swap
    [newGrid[row1][col1], newGrid[row2][col2]] = [newGrid[row2][col2], newGrid[row1][col1]];
    setGrid(newGrid);
    
    // If BOTH tiles are special, activate special combination!
    if (tile1Special && tile2Special) {
      setMoves(prev => prev - 1); // Costs a move
      setTimeout(() => {
        activateSpecialCombination(row1, col1, row2, col2, tile1Special, tile2Special, newGrid);
      }, 300);
      return;
    }
    
    setTimeout(() => {
      const { matches, matchGroups, lShapeMatches, connectedGroups } = findMatches(newGrid);
      
      if (matches.length > 0) {
        setMoves(prev => prev - 1);
        const comboIncrease = matchGroups.length + (lShapeMatches?.length || 0);
        setCombo(comboIncrease);
        setMaxComboReached(current => Math.max(current, comboIncrease));
        processMatches(newGrid, matchGroups, lShapeMatches, comboIncrease, 0, connectedGroups);
      } else {
        // Swap back - invalid move, turn is complete
        const revertGrid = newGrid.map(r => r.map(t => t ? { ...t } : null));
        [revertGrid[row1][col1], revertGrid[row2][col2]] = [revertGrid[row2][col2], revertGrid[row1][col1]];
        setGrid(revertGrid);
        setIsAnimating(false);
        setTurnComplete(true); // No valid move, turn complete
      }
    }, 300);
  };
  
  // =============================================================================
  // MATCH FINDING AND PROCESSING
  // =============================================================================
  
  const findMatches = (currentGrid) => {
    const matches = [];
    const matchGroups = [];
    const visited = new Set();
    
    // Find horizontal matches
    for (let row = 0; row < ROWS; row++) {
      let col = 0;
      while (col < COLS) {
        const tile = currentGrid[row][col];
        if (!tile) { col++; continue; }
        
        let matchLength = 1;
        while (col + matchLength < COLS && 
               currentGrid[row][col + matchLength]?.type === tile.type) {
          matchLength++;
        }
        
        if (matchLength >= 3) {
          const tiles = [];
          for (let i = 0; i < matchLength; i++) {
            tiles.push({ row, col: col + i });
            matches.push({ row, col: col + i });
            visited.add(`${row}-${col + i}`);
          }
          matchGroups.push({ tiles, length: matchLength, direction: 'horizontal', tileType: tile.type });
        }
        col += matchLength;
      }
    }
    
    // Find vertical matches
    for (let col = 0; col < COLS; col++) {
      let row = 0;
      while (row < ROWS) {
        const tile = currentGrid[row][col];
        if (!tile) { row++; continue; }
        
        let matchLength = 1;
        while (row + matchLength < ROWS && 
               currentGrid[row + matchLength][col]?.type === tile.type) {
          matchLength++;
        }
        
        if (matchLength >= 3) {
          const tiles = [];
          for (let i = 0; i < matchLength; i++) {
            tiles.push({ row: row + i, col });
            if (!visited.has(`${row + i}-${col}`)) {
              matches.push({ row: row + i, col });
            }
          }
          matchGroups.push({ tiles, length: matchLength, direction: 'vertical', tileType: tile.type });
        }
        row += matchLength;
      }
    }
    
    // Find L-shapes (intersections of horizontal and vertical matches)
    const lShapeMatches = [];
    for (let i = 0; i < matchGroups.length; i++) {
      for (let j = i + 1; j < matchGroups.length; j++) {
        if (matchGroups[i].direction !== matchGroups[j].direction &&
            matchGroups[i].tileType === matchGroups[j].tileType) {
          const intersection = matchGroups[i].tiles.find(t1 => 
            matchGroups[j].tiles.some(t2 => t1.row === t2.row && t1.col === t2.col)
          );
          if (intersection) {
            const tileType = currentGrid[intersection.row][intersection.col]?.type;
            lShapeMatches.push({ ...intersection, tileType });
          }
        }
      }
    }
    
    // OPTION B: Find connected match groups (same tile type, sharing tiles)
    // This determines total unique tiles for supernova/hypernova creation
    const connectedGroups = [];
    const groupUsed = new Array(matchGroups.length).fill(false);
    
    for (let i = 0; i < matchGroups.length; i++) {
      if (groupUsed[i]) continue;
      
      // Start a new connected group
      const connectedTiles = new Set();
      const connectedGroupIndices = [i];
      const tileType = matchGroups[i].tileType;
      
      // Add all tiles from this group
      matchGroups[i].tiles.forEach(t => connectedTiles.add(`${t.row}-${t.col}`));
      groupUsed[i] = true;
      
      // Find all groups that connect to this one (same type, share a tile)
      let foundNew = true;
      while (foundNew) {
        foundNew = false;
        for (let j = 0; j < matchGroups.length; j++) {
          if (groupUsed[j] || matchGroups[j].tileType !== tileType) continue;
          
          // Check if this group shares any tile with our connected group
          const shares = matchGroups[j].tiles.some(t => connectedTiles.has(`${t.row}-${t.col}`));
          if (shares) {
            matchGroups[j].tiles.forEach(t => connectedTiles.add(`${t.row}-${t.col}`));
            connectedGroupIndices.push(j);
            groupUsed[j] = true;
            foundNew = true;
          }
        }
      }
      
      // Convert Set back to array of tile objects
      const tilesArray = Array.from(connectedTiles).map(key => {
        const [row, col] = key.split('-').map(Number);
        return { row, col };
      });
      
      connectedGroups.push({
        tiles: tilesArray,
        totalUniqueTiles: tilesArray.length,
        tileType,
        groupIndices: connectedGroupIndices
      });
    }
    
    return { matches, matchGroups, lShapeMatches, connectedGroups };
  };
  
  const processMatches = (currentGrid, matchGroups, lShapeMatches, currentCombo, generation = 0, connectedGroups = []) => {
    setMatchedTiles(matchGroups.flatMap(g => g.tiles));
    
    // Calculate score
    let totalPoints = 0;
    const multiplier = getMultiplier(currentCombo);
    
    matchGroups.forEach(group => {
      const basePoints = group.length * 10;
      totalPoints += Math.floor(basePoints * multiplier);
    });
    
    // Bonus for L-shapes
    if (lShapeMatches && lShapeMatches.length > 0) {
      totalPoints += lShapeMatches.length * 50;
    }
    
    setScore(prev => prev + totalPoints);
    setCurrentTurnScore(prev => prev + totalPoints);
    
    // Add popup
    if (matchGroups.length > 0) {
      const firstMatch = matchGroups[0].tiles[0];
      addScorePopup(firstMatch.row, firstMatch.col, totalPoints);
    }
    
    // Remove matches and create specials
    setTimeout(() => {
      removeMatches(currentGrid, matchGroups, lShapeMatches, generation, connectedGroups);
    }, 400);
  };
  
  // Activate a special tile's effect
  const activateSpecialTile = (row, col, currentGrid, alreadyCleared = new Set()) => {
    const tile = currentGrid[row]?.[col];
    if (!tile || !tile.special) return { tilesToClear: [], points: 0, message: '', chainedSpecials: [] };
    
    const tilesToClear = [];
    const chainedSpecials = [];
    let points = 0;
    let message = '';
    const posKey = `${row}-${col}`;
    
    if (alreadyCleared.has(posKey)) return { tilesToClear: [], points: 0, message: '', chainedSpecials: [] };
    alreadyCleared.add(posKey);
    
    if (tile.special === 'line') {
      // Clear entire row
      for (let c = 0; c < COLS; c++) {
        if (currentGrid[row][c]) {
          tilesToClear.push({ row, col: c });
          if (currentGrid[row][c].special && c !== col && !alreadyCleared.has(`${row}-${c}`)) {
            chainedSpecials.push({ row, col: c, type: currentGrid[row][c].special });
          }
        }
      }
      points = tilesToClear.length * 30;
      message = `âš¡ LINE CLEAR! +${points}`;
    } else if (tile.special === 'bomb') {
      // Clear 3x3 area
      for (let r = Math.max(0, row - 1); r <= Math.min(ROWS - 1, row + 1); r++) {
        for (let c = Math.max(0, col - 1); c <= Math.min(COLS - 1, col + 1); c++) {
          if (currentGrid[r][c]) {
            tilesToClear.push({ row: r, col: c });
            if (currentGrid[r][c].special && !(r === row && c === col) && !alreadyCleared.has(`${r}-${c}`)) {
              chainedSpecials.push({ row: r, col: c, type: currentGrid[r][c].special });
            }
          }
        }
      }
      points = tilesToClear.length * 45;
      message = `ðŸ’£ BOOM! +${points}`;
    } else if (tile.special === 'cross') {
      // Clear entire row AND column
      for (let c = 0; c < COLS; c++) {
        if (currentGrid[row][c]) {
          tilesToClear.push({ row, col: c });
          if (currentGrid[row][c].special && c !== col && !alreadyCleared.has(`${row}-${c}`)) {
            chainedSpecials.push({ row, col: c, type: currentGrid[row][c].special });
          }
        }
      }
      for (let r = 0; r < ROWS; r++) {
        if (r !== row && currentGrid[r][col]) {
          tilesToClear.push({ row: r, col });
          if (currentGrid[r][col].special && !alreadyCleared.has(`${r}-${col}`)) {
            chainedSpecials.push({ row: r, col, type: currentGrid[r][col].special });
          }
        }
      }
      points = tilesToClear.length * 38;
      message = `âœ¨ CROSS BLAST! +${points}`;
    } else if (tile.special === 'supernova') {
      // Clear 5x5 area
      for (let r = Math.max(0, row - 2); r <= Math.min(ROWS - 1, row + 2); r++) {
        for (let c = Math.max(0, col - 2); c <= Math.min(COLS - 1, col + 2); c++) {
          if (currentGrid[r][c]) {
            tilesToClear.push({ row: r, col: c });
            if (currentGrid[r][c].special && !(r === row && c === col) && !alreadyCleared.has(`${r}-${c}`)) {
              chainedSpecials.push({ row: r, col: c, type: currentGrid[r][c].special });
            }
          }
        }
      }
      points = 1500;
      message = `ðŸŒŒ SUPERNOVA! +${points}`;
    } else if (tile.special === 'hypernova') {
      // Clear entire board!
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (currentGrid[r][c]) {
            tilesToClear.push({ row: r, col: c });
          }
        }
      }
      points = 5000;
      message = `ðŸŒ  HYPERNOVA!!! +${points}`;
    }
    
    return { tilesToClear, points, message, chainedSpecials };
  };
  
  // Activate enhanced effects when two special tiles are swapped together
  const activateSpecialCombination = (row1, col1, row2, col2, type1, type2, currentGrid) => {
    setIsAnimating(true);
    
    const tilesToRemove = [];
    let points = 0;
    let message = '';
    
    // Sort types for consistent comparison
    const combo = [type1, type2].sort().join('+');
    
    // Use the midpoint of the two tiles as the center
    const centerRow = Math.floor((row1 + row2) / 2);
    const centerCol = Math.floor((col1 + col2) / 2);
    
    if (combo === 'line+line') {
      // Clear entire row AND column (cross effect)
      for (let c = 0; c < COLS; c++) {
        if (currentGrid[row1][c]) tilesToRemove.push({ row: row1, col: c });
      }
      for (let r = 0; r < ROWS; r++) {
        if (currentGrid[r][col1] && r !== row1) tilesToRemove.push({ row: r, col: col1 });
      }
      points = 700;
      message = 'âš¡âš¡ DOUBLE LINE! +700';
    } else if (combo === 'bomb+bomb') {
      // Clear 5Ã—5 area (upgraded from 3Ã—3)
      for (let r = Math.max(0, row1 - 2); r <= Math.min(ROWS - 1, row1 + 2); r++) {
        for (let c = Math.max(0, col1 - 2); c <= Math.min(COLS - 1, col1 + 2); c++) {
          if (currentGrid[r][c]) tilesToRemove.push({ row: r, col: c });
        }
      }
      points = 1000;
      message = 'ðŸ’£ðŸ’£ MEGA BLAST! +1000';
    } else if (combo === 'cross+cross') {
      // Clear 3 rows + 3 columns centered on swap
      for (let r = Math.max(0, row1 - 1); r <= Math.min(ROWS - 1, row1 + 1); r++) {
        for (let c = 0; c < COLS; c++) {
          if (currentGrid[r][c]) tilesToRemove.push({ row: r, col: c });
        }
      }
      for (let r = 0; r < ROWS; r++) {
        for (let c = Math.max(0, col1 - 1); c <= Math.min(COLS - 1, col1 + 1); c++) {
          if (currentGrid[r][c] && !tilesToRemove.some(t => t.row === r && t.col === c)) {
            tilesToRemove.push({ row: r, col: c });
          }
        }
      }
      points = 850;
      message = 'âœ¨âœ¨ DOUBLE CROSS! +850';
    } else if (combo === 'bomb+line') {
      // Clear entire row + 3Ã—3 area (T-shape effect)
      for (let c = 0; c < COLS; c++) {
        if (currentGrid[row1][c]) tilesToRemove.push({ row: row1, col: c });
      }
      for (let r = Math.max(0, row1 - 1); r <= Math.min(ROWS - 1, row1 + 1); r++) {
        for (let c = Math.max(0, col1 - 1); c <= Math.min(COLS - 1, col1 + 1); c++) {
          if (currentGrid[r][c] && r !== row1) tilesToRemove.push({ row: r, col: c });
        }
      }
      points = 800;
      message = 'ðŸ’£âš¡ LINE BOMB! +800';
    } else if (combo === 'cross+line') {
      // Clear 2 rows + 2 columns
      for (let r = Math.max(0, row1 - 1); r <= Math.min(ROWS - 1, row1 + 1); r++) {
        for (let c = 0; c < COLS; c++) {
          if (currentGrid[r][c]) tilesToRemove.push({ row: r, col: c });
        }
      }
      for (let r = 0; r < ROWS; r++) {
        if (currentGrid[r][col1] && (r < row1 - 1 || r > row1 + 1)) {
          tilesToRemove.push({ row: r, col: col1 });
        }
      }
      points = 750;
      message = 'âœ¨âš¡ CROSS LINE! +750';
    } else if (combo === 'bomb+cross') {
      // Clear row + column + 5Ã—5 area
      for (let c = 0; c < COLS; c++) {
        if (currentGrid[row1][c]) tilesToRemove.push({ row: row1, col: c });
      }
      for (let r = 0; r < ROWS; r++) {
        if (currentGrid[r][col1] && r !== row1) tilesToRemove.push({ row: r, col: col1 });
      }
      for (let r = Math.max(0, row1 - 2); r <= Math.min(ROWS - 1, row1 + 2); r++) {
        for (let c = Math.max(0, col1 - 2); c <= Math.min(COLS - 1, col1 + 2); c++) {
          if (currentGrid[r][c] && !tilesToRemove.some(t => t.row === r && t.col === c)) {
            tilesToRemove.push({ row: r, col: c });
          }
        }
      }
      points = 900;
      message = 'ðŸ’£âœ¨ CROSS BOMB! +900';
    } else if (combo === 'supernova+supernova') {
      // Clear nearly entire board (10Ã—10 equivalent)
      for (let r = Math.max(0, row1 - 5); r <= Math.min(ROWS - 1, row1 + 5); r++) {
        for (let c = Math.max(0, col1 - 5); c <= Math.min(COLS - 1, col1 + 5); c++) {
          if (currentGrid[r][c]) tilesToRemove.push({ row: r, col: c });
        }
      }
      points = 5000;
      message = 'ðŸŒŒðŸŒŒ DUAL SUPERNOVA! +5000';
    } else if (combo === 'hypernova+hypernova') {
      // Clear entire board + massive bonus
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (currentGrid[r][c]) tilesToRemove.push({ row: r, col: c });
        }
      }
      points = 10000;
      message = 'ðŸŒ ðŸŒ  DUAL HYPERNOVA!!! +10000';
    } else if (combo === 'hypernova+supernova') {
      // Clear entire board + big bonus
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (currentGrid[r][c]) tilesToRemove.push({ row: r, col: c });
        }
      }
      points = 8000;
      message = 'ðŸŒ ðŸŒŒ NOVA FUSION! +8000';
    } else if (combo === 'bomb+supernova' || combo === 'cross+supernova' || combo === 'line+supernova') {
      // Clear 7Ã—7 area
      for (let r = Math.max(0, row1 - 3); r <= Math.min(ROWS - 1, row1 + 3); r++) {
        for (let c = Math.max(0, col1 - 3); c <= Math.min(COLS - 1, col1 + 3); c++) {
          if (currentGrid[r][c]) tilesToRemove.push({ row: r, col: c });
        }
      }
      points = 3000;
      const icon1 = type1 === 'supernova' ? 'ðŸŒŒ' : (type1 === 'line' ? 'âš¡' : type1 === 'bomb' ? 'ðŸ’£' : 'âœ¨');
      const icon2 = type2 === 'supernova' ? 'ðŸŒŒ' : (type2 === 'line' ? 'âš¡' : type2 === 'bomb' ? 'ðŸ’£' : 'âœ¨');
      message = `${icon1}${icon2} SUPERNOVA COMBO! +3000`;
    } else if (combo === 'bomb+hypernova' || combo === 'cross+hypernova' || combo === 'line+hypernova') {
      // Clear entire board
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (currentGrid[r][c]) tilesToRemove.push({ row: r, col: c });
        }
      }
      points = 6000;
      const icon1 = type1 === 'hypernova' ? 'ðŸŒ ' : (type1 === 'line' ? 'âš¡' : type1 === 'bomb' ? 'ðŸ’£' : 'âœ¨');
      const icon2 = type2 === 'hypernova' ? 'ðŸŒ ' : (type2 === 'line' ? 'âš¡' : type2 === 'bomb' ? 'ðŸ’£' : 'âœ¨');
      message = `${icon1}${icon2} HYPERNOVA COMBO! +6000`;
    }
    
    // Remove duplicates
    const uniqueTiles = [];
    const seen = new Set();
    tilesToRemove.forEach(tile => {
      const key = `${tile.row}-${tile.col}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueTiles.push(tile);
      }
    });
    
    // Award points and show popup
    addScorePopup(row1, col1, points, message);
    setScore(prev => prev + points);
    setCurrentTurnScore(prev => prev + points);
    setMatchedTiles(uniqueTiles);
    
    // Remove tiles and apply gravity
    setTimeout(() => {
      const newGrid = currentGrid.map(r => r.map(t => t ? { ...t } : null));
      uniqueTiles.forEach(({ row, col }) => { newGrid[row][col] = null; });
      setGrid(newGrid);
      setMatchedTiles([]);
      
      setTimeout(() => applyGravity(newGrid, 0), 400);
    }, 400);
  };
  
  const removeMatches = (currentGrid, matchGroups, lShapeMatches, generation, connectedGroups = []) => {
    const newGrid = currentGrid.map(r => r.map(t => t ? { ...t } : null));
    const specialsToCreate = [];
    const claimedPositions = new Set();
    
    // Collect all tiles being cleared and check for specials
    const allTilesToClear = new Set();
    const specialsToActivate = [];
    const alreadyActivated = new Set();
    
    // First pass: identify all matched tiles and any specials in them
    matchGroups.forEach(group => {
      group.tiles.forEach(({ row, col }) => {
        allTilesToClear.add(`${row}-${col}`);
        const tile = currentGrid[row]?.[col];
        if (tile?.special && !alreadyActivated.has(`${row}-${col}`)) {
          specialsToActivate.push({ row, col, type: tile.special });
          alreadyActivated.add(`${row}-${col}`);
        }
      });
    });
    
    // Activate all specials that were matched
    let totalSpecialPoints = 0;
    const allSpecialClears = new Set();
    
    specialsToActivate.forEach(special => {
      const result = activateSpecialTile(special.row, special.col, currentGrid, allSpecialClears);
      totalSpecialPoints += result.points;
      result.tilesToClear.forEach(t => allTilesToClear.add(`${t.row}-${t.col}`));
      
      if (result.message) {
        addScorePopup(special.row, special.col, result.points, result.message);
      }
      
      // Process chained specials
      result.chainedSpecials.forEach(chained => {
        if (!alreadyActivated.has(`${chained.row}-${chained.col}`)) {
          const chainResult = activateSpecialTile(chained.row, chained.col, currentGrid, allSpecialClears);
          totalSpecialPoints += chainResult.points;
          chainResult.tilesToClear.forEach(t => allTilesToClear.add(`${t.row}-${t.col}`));
          if (chainResult.message) {
            addScorePopup(chained.row, chained.col, chainResult.points, chainResult.message);
          }
          alreadyActivated.add(`${chained.row}-${chained.col}`);
        }
      });
    });
    
    // Add special points to score
    if (totalSpecialPoints > 0) {
      setScore(prev => prev + totalSpecialPoints);
      setCurrentTurnScore(prev => prev + totalSpecialPoints);
    }
    
    // OPTION B: Use connectedGroups for special creation based on TOTAL UNIQUE TILES
    if (connectedGroups && connectedGroups.length > 0 && generation < 3) {
      // Sort by total unique tiles (largest first)
      const sortedConnected = [...connectedGroups].sort((a, b) => b.totalUniqueTiles - a.totalUniqueTiles);
      
      sortedConnected.forEach(group => {
        if (group.totalUniqueTiles >= 4) {
          // Find center tile of the connected group
          let centerRow = 0, centerCol = 0;
          group.tiles.forEach(t => { centerRow += t.row; centerCol += t.col; });
          centerRow = Math.round(centerRow / group.tiles.length);
          centerCol = Math.round(centerCol / group.tiles.length);
          
          // Find the actual tile closest to center that's in the group
          let bestTile = group.tiles[0];
          let bestDist = Infinity;
          group.tiles.forEach(t => {
            const dist = Math.abs(t.row - centerRow) + Math.abs(t.col - centerCol);
            if (dist < bestDist && !claimedPositions.has(`${t.row}-${t.col}`)) {
              bestDist = dist;
              bestTile = t;
            }
          });
          
          const posKey = `${bestTile.row}-${bestTile.col}`;
          if (!claimedPositions.has(posKey)) {
            let specialType = 'line';
            // OPTION B: Use totalUniqueTiles for determination
            if (group.totalUniqueTiles >= 7) specialType = 'hypernova';
            else if (group.totalUniqueTiles === 6) specialType = 'supernova';
            else if (group.totalUniqueTiles === 5) specialType = 'bomb';
            // 4 tiles = line (default)
            
            // Check if this is an L-shape (intersection exists) - upgrade to cross
            const hasIntersection = lShapeMatches && lShapeMatches.some(l => 
              group.tiles.some(t => t.row === l.row && t.col === l.col)
            );
            if (hasIntersection && specialType === 'line') {
              specialType = 'cross';
            }
            
            const tileColor = group.tileType ?? 0;
            specialsToCreate.push({ row: bestTile.row, col: bestTile.col, type: specialType, tileColor });
            group.tiles.forEach(t => claimedPositions.add(`${t.row}-${t.col}`));
          }
        }
      });
    } else {
      // Fallback to old logic if no connectedGroups (shouldn't happen)
      const sortedGroups = [...matchGroups].sort((a, b) => b.length - a.length);
      
      sortedGroups.forEach(group => {
        if (group.length >= 4 && generation < 3) {
          const midIndex = Math.floor(group.tiles.length / 2);
          const midTile = group.tiles[midIndex];
          const posKey = `${midTile.row}-${midTile.col}`;
          
          if (!claimedPositions.has(posKey)) {
            let specialType = 'line';
            if (group.length >= 7) specialType = 'hypernova';
            else if (group.length === 6) specialType = 'supernova';
            else if (group.length === 5) specialType = 'bomb';
            
            const tileColor = currentGrid[midTile.row]?.[midTile.col]?.type ?? 0;
            specialsToCreate.push({ row: midTile.row, col: midTile.col, type: specialType, tileColor });
            group.tiles.forEach(t => claimedPositions.add(`${t.row}-${t.col}`));
          }
        }
      });
      
      // L-shapes create cross specials (old logic)
      if (lShapeMatches && generation < 3) {
        lShapeMatches.forEach(l => {
          const posKey = `${l.row}-${l.col}`;
          if (!claimedPositions.has(posKey)) {
            specialsToCreate.push({ row: l.row, col: l.col, type: 'cross', tileColor: l.tileType ?? 0 });
            claimedPositions.add(posKey);
          }
        });
      }
    }
    
    // Clear all matched tiles (including special effect tiles)
    allTilesToClear.forEach(posKey => {
      const [row, col] = posKey.split('-').map(Number);
      newGrid[row][col] = null;
    });
    
    // Create special tiles from 4+ tile matches
    // NEW IN v6.6: Always create specials if match qualifies, even if a special was activated
    specialsToCreate.forEach(({ row, col, type, tileColor }) => {
      newGrid[row][col] = {
        type: tileColor,
        id: `special-${row}-${col}-${Date.now()}`,
        special: type,
        isNew: false,
        animX: col * (TILE_SIZE + TILE_GAP),
        animY: row * (TILE_SIZE + TILE_GAP)
      };
    });
    
    setGrid(newGrid);
    setMatchedTiles([]);
    
    setTimeout(() => applyGravity(newGrid, generation), 500);
  };
  
  const applyGravity = (currentGrid, generation) => {
    const newGrid = currentGrid.map(r => r.map(t => t ? { ...t } : null));
    
    for (let col = 0; col < COLS; col++) {
      let emptyRow = ROWS - 1;
      for (let row = ROWS - 1; row >= 0; row--) {
        if (newGrid[row][col] !== null) {
          if (row !== emptyRow) {
            newGrid[emptyRow][col] = newGrid[row][col];
            newGrid[emptyRow][col].animY = row * (TILE_SIZE + TILE_GAP); // Animate from old position
            newGrid[row][col] = null;
          }
          emptyRow--;
        }
      }
    }
    
    setGrid(newGrid);
    setTimeout(() => fillEmptySpaces(newGrid, generation), 400);
  };
  
  const fillEmptySpaces = (currentGrid, generation) => {
    const newGrid = currentGrid.map(r => r.map(t => t ? { ...t, isNew: false } : null));
    
    for (let col = 0; col < COLS; col++) {
      let emptyCount = 0;
      for (let row = 0; row < ROWS; row++) {
        if (newGrid[row][col] === null) emptyCount++;
      }
      
      for (let row = 0; row < ROWS; row++) {
        if (newGrid[row][col] === null) {
          newGrid[row][col] = {
            type: Math.floor(Math.random() * TILE_TYPES),
            id: `${row}-${col}-${Date.now()}-${Math.random()}`,
            special: null,
            isNew: true,
            animX: col * (TILE_SIZE + TILE_GAP),
            animY: -emptyCount * (TILE_SIZE + TILE_GAP) // Start above board
          };
          emptyCount--;
        }
      }
    }
    
    setGrid(newGrid);
    
    setTimeout(() => {
      const { matches, matchGroups, lShapeMatches, connectedGroups } = findMatches(newGrid);
      if (matches.length > 0) {
        const comboIncrease = matchGroups.length + (lShapeMatches?.length || 0);
        setCombo(prev => {
          const newCombo = prev + comboIncrease;
          setMaxComboReached(current => Math.max(current, newCombo));
          return newCombo;
        });
        processMatches(newGrid, matchGroups, lShapeMatches, combo + comboIncrease, generation + 1, connectedGroups);
      } else {
        // No more matches - turn is complete
        setIsAnimating(false);
        setLastCombo(combo);
        setCombo(0);
        // v6.7: Wait a moment for score state to settle, then mark turn complete
        setTimeout(() => {
          setTurnComplete(true);
          checkForValidMoves(newGrid);
        }, 100);
      }
    }, 500);
  };
  
  const checkForValidMoves = (currentGrid) => {
    if (gameState !== 'playing') return;
    setTimeout(() => {
      if (!hasValidMoves(currentGrid)) {
        setShowNoMoves(true);
      }
    }, 300);
  };
  
  const shuffleBoard = () => {
    setShowNoMoves(false);
    setIsAnimating(true);
    
    const tiles = [];
    grid.forEach(row => {
      row.forEach(tile => {
        if (tile) tiles.push({ ...tile, isNew: false });
      });
    });
    
    for (let i = tiles.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
    }
    
    const newGrid = [];
    let tileIndex = 0;
    for (let row = 0; row < ROWS; row++) {
      newGrid[row] = [];
      for (let col = 0; col < COLS; col++) {
        if (tileIndex < tiles.length) {
          newGrid[row][col] = { 
            ...tiles[tileIndex], 
            id: `${row}-${col}-${Date.now()}`, 
            isNew: true,
            animX: col * (TILE_SIZE + TILE_GAP),
            animY: row * (TILE_SIZE + TILE_GAP)
          };
          tileIndex++;
        }
      }
    }
    
    setGrid(newGrid);
    setTimeout(() => setIsAnimating(false), 600);
  };
  
  // Utility functions
  const getMultiplier = (comboValue) => {
    if (comboValue === 0) return 1.0;
    if (comboValue === 1) return 1.5;
    if (comboValue === 2) return 2.0;
    if (comboValue === 3) return 2.5;
    if (comboValue === 4) return 3.0;
    if (comboValue === 5) return 3.5;
    if (comboValue >= 6) return 4.0 + (comboValue - 6) * 0.1;
    return 1.0;
  };
  
  const addScorePopup = (row, col, points, text = null) => {
    setScorePopups(prev => [...prev, {
      id: Date.now() + Math.random(),
      row, col, points, text,
      combo
    }]);
  };
  
  const restartGame = () => {
    setGrid(initializeGrid());
    setScore(0);
    setMoves(MIN_MOVES + Math.floor(Math.random() * (MAX_MOVES - MIN_MOVES + 1)));
    const rawTarget = BASE_TARGET + Math.floor(Math.random() * TARGET_VARIANCE) + difficultyBonus;
    setLevelTarget(Math.round(rawTarget / 100) * 100);
    setGameState('playing');
    setSelectedTile(null);
    setIsAnimating(false);
    setMatchedTiles([]);
    setScorePopups([]);
    setCombo(0);
    setLastCombo(0);
    setShowNoMoves(false);
    setMaxComboReached(0);
    setTargetReached(false);
    setPendingSpecials([]);
    setCurrentTurnScore(0);
    setSpecialBonusMultiplier(0);
    setTurnComplete(true); // v6.7: Reset turn state
  };
  
  // =============================================================================
  // RENDER
  // =============================================================================
  
  return (
    <div style={{
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
      fontFamily: 'Arial, sans-serif',
      padding: '20px',
      paddingBottom: '60px',
      touchAction: 'none',
      userSelect: 'none'
    }}>
      {/* Header */}
      <div style={{
        background: 'rgba(255, 255, 255, 0.95)',
        borderRadius: '15px',
        padding: '12px 20px',
        marginBottom: '20px',
        boxShadow: '0 8px 16px rgba(0,0,0,0.2)',
        width: `${boardWidth + 30}px`,
        minHeight: '110px',
        textAlign: 'center',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'space-between'
      }}>
        <h1 style={{ margin: '0', color: '#333', fontSize: '20px', textShadow: '2px 2px 4px rgba(0,0,0,0.1)' }}>
          ðŸŽ® Match-3 <span style={{ fontSize: '12px', color: '#888' }}>v6.8.1 Canvas</span>
        </h1>
        <div style={{
          display: 'flex',
          justifyContent: 'space-around',
          fontSize: '16px',
          fontWeight: 'bold',
          color: '#555'
        }}>
          <div>Score: <span style={{ color: '#667eea' }}>{score}</span></div>
          <div>Moves: <span style={{ color: moves <= 5 ? '#FF4444' : moves <= 10 ? '#FF8C00' : '#44FF44' }}>{moves}</span></div>
          <div>Target: <span style={{ 
            color: '#FFD700', 
            textShadow: '1px 1px 0 #B8860B, -1px -1px 0 #B8860B, 1px -1px 0 #B8860B, -1px 1px 0 #B8860B',
            fontSize: '17px'
          }}>{levelTarget}</span></div>
        </div>
        
        {/* Combo display */}
        <div style={{ minHeight: '24px', display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
          {(combo > 0 || lastCombo > 0) && (
            <div style={{
              fontSize: '16px',
              color: (combo > 0 ? combo : lastCombo) >= 4 ? '#FFD700' : '#FF8C00',
              fontWeight: 'bold',
              textShadow: '1px 1px 2px rgba(0,0,0,0.2)',
              opacity: combo > 0 ? 1 : 0.7
            }}>
              {(combo > 0 ? combo : lastCombo) >= 4 ? 'ðŸŒŸ MEGA COMBO' : 'ðŸ”¥ COMBO'} x{(combo > 0 ? combo : lastCombo) + 1}
            </div>
          )}
          {!(combo > 0 || lastCombo > 0) && (highScore > 0 || allTimeHighCombo > 0) && (
            <div style={{ fontSize: '12px', color: '#888', display: 'flex', gap: '15px', justifyContent: 'center' }}>
              {highScore > 0 && <span>ðŸ† {highScore}</span>}
              {allTimeHighCombo > 0 && <span>ðŸ”¥ Best: x{allTimeHighCombo + 1}</span>}
            </div>
          )}
        </div>
      </div>
      
      {/* Game Board - Canvas */}
      <div style={{
        background: 'rgba(255, 255, 255, 0.95)',
        borderRadius: '15px',
        padding: '15px',
        boxShadow: '0 8px 16px rgba(0,0,0,0.2)',
        position: 'relative'
      }}>
        <canvas
          ref={canvasRef}
          onClick={handleCanvasClick}
          onMouseDown={handleDragStart}
          onMouseMove={handleDragMove}
          onMouseUp={handleDragEnd}
          onMouseLeave={handleDragEnd}
          onTouchStart={handleDragStart}
          onTouchMove={handleDragMove}
          onTouchEnd={handleDragEnd}
          style={{
            borderRadius: '10px',
            cursor: isAnimating ? 'default' : 'pointer',
            touchAction: 'none'
          }}
        />
        
        {/* Score Popups */}
        {scorePopups.map(popup => (
          <div
            key={popup.id}
            style={{
              position: 'absolute',
              left: `${15 + popup.col * (TILE_SIZE + TILE_GAP)}px`,
              top: `${15 + popup.row * (TILE_SIZE + TILE_GAP)}px`,
              fontSize: popup.text ? '18px' : '24px',
              fontWeight: '900',
              color: '#FFD700',
              textShadow: '2px 2px 0px #000, -1px -1px 0px #000, 1px -1px 0px #000, -1px 1px 0px #000, 0 0 15px rgba(255,215,0,0.9)',
              pointerEvents: 'none',
              animation: 'scorePopup 2s ease-out forwards',
              zIndex: 1000,
              whiteSpace: 'nowrap',
              background: popup.text ? 'rgba(0,0,0,0.9)' : 'transparent',
              padding: popup.text ? '10px 14px' : '0',
              borderRadius: popup.text ? '10px' : '0',
              border: popup.text ? '2px solid #FFD700' : 'none',
              boxShadow: popup.text ? '0 0 20px rgba(255,215,0,0.7)' : 'none'
            }}
          >
            {popup.text || `+${popup.points}`}
            {!popup.text && popup.combo > 0 && ` x${popup.combo + 1}`}
          </div>
        ))}
      </div>
      
      {/* No Valid Moves Dialog */}
      {showNoMoves && (
        <div style={{
          position: 'fixed',
          top: 0, left: 0, right: 0, bottom: 0,
          background: 'rgba(0,0,0,0.7)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 999
        }}>
          <div style={{
            background: 'white',
            borderRadius: '20px',
            padding: '30px',
            textAlign: 'center',
            maxWidth: '350px',
            boxShadow: '0 10px 40px rgba(0,0,0,0.3)'
          }}>
            <h3 style={{ fontSize: '24px', margin: '0 0 15px 0', color: '#FF8C00' }}>
              ðŸ˜” No Valid Moves!
            </h3>
            <p style={{ fontSize: '16px', color: '#555', marginBottom: '20px' }}>
              Shuffle to continue?
            </p>
            <button
              onClick={shuffleBoard}
              style={{
                padding: '12px 30px',
                fontSize: '18px',
                background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                color: 'white',
                border: 'none',
                borderRadius: '10px',
                cursor: 'pointer',
                fontWeight: 'bold'
              }}
            >
              ðŸ”€ Shuffle Board
            </button>
          </div>
        </div>
      )}
      
      {/* Game Over / Won Screen */}
      {(gameState === 'gameover' || gameState === 'won') && (() => {
        const moveBonusAmount = Math.max(0, moves) * WIN_BONUS_PER_MOVE;
        const { bonus: specialsBonusAmount, specials } = calculateUnusedSpecialsBonus(grid);
        const totalSpecials = specials.line + specials.bomb + specials.cross + specials.supernova + specials.hypernova;
        
        return (
          <div style={{
            position: 'fixed',
            top: 0, left: 0, right: 0,
            minHeight: '120px',
            background: gameState === 'won' 
              ? 'linear-gradient(135deg, rgba(68, 255, 68, 0.98) 0%, rgba(40, 180, 40, 0.98) 100%)'
              : 'linear-gradient(135deg, rgba(255, 68, 68, 0.98) 0%, rgba(180, 40, 40, 0.98) 100%)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            gap: '25px',
            zIndex: 1000,
            boxShadow: '0 4px 20px rgba(0,0,0,0.4)',
            padding: '10px 20px',
            flexWrap: 'wrap'
          }}>
            <div style={{ textAlign: 'center', color: 'white', minWidth: '200px' }}>
              <div style={{ fontSize: '26px', fontWeight: 'bold', textShadow: '2px 2px 4px rgba(0,0,0,0.3)', marginBottom: '4px' }}>
                {gameState === 'won' ? 'ðŸŽ‰ Victory!' : 'ðŸ˜” Game Over'}
              </div>
              <div style={{ fontSize: '22px' }}>
                Final Score: <strong>{score}</strong>
                {highScore > 0 && score >= highScore && (
                  <span style={{ fontSize: '14px', marginLeft: '8px', color: '#FFD700' }}>ðŸ† High!</span>
                )}
              </div>
            </div>
            
            <div style={{ 
              textAlign: 'left', 
              color: 'white', 
              fontSize: '13px', 
              lineHeight: '1.5',
              background: 'rgba(0,0,0,0.2)',
              padding: '8px 12px',
              borderRadius: '8px',
              minWidth: '180px'
            }}>
              {gameState === 'won' && moves > 0 && (
                <div>â­ Moves: {moves} Ã— {WIN_BONUS_PER_MOVE} = +{moveBonusAmount}</div>
              )}
              {totalSpecials > 0 && (
                <div>âœ¨ Specials: {totalSpecials} = +{specialsBonusAmount}</div>
              )}
              <div>ðŸ”¥ Best Combo: x{maxComboReached + 1}</div>
            </div>
            
            <button
              onClick={restartGame}
              style={{
                padding: '10px 25px',
                fontSize: '16px',
                background: 'white',
                color: gameState === 'won' ? '#28b428' : '#b42828',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                fontWeight: 'bold',
                boxShadow: '0 2px 8px rgba(0,0,0,0.2)'
              }}
            >
              ðŸ”„ Play Again
            </button>
          </div>
        );
      })()}
      
      {/* Instructions */}
      <div style={{
        marginTop: '20px',
        background: 'rgba(255, 255, 255, 0.9)',
        padding: '12px 16px',
        borderRadius: '10px',
        maxWidth: `${boardWidth + 30}px`,
        fontSize: '12px',
        color: '#555',
        textAlign: 'center',
        lineHeight: '1.5'
      }}>
        <strong>ðŸŽ¯ Match 3+ tiles!</strong> â€¢ 
        <strong>âš¡4-match:</strong> Line â€¢ 
        <strong>ðŸ’£5-match:</strong> Bomb â€¢ 
        <strong>âœ¨L-shape:</strong> Cross
      </div>
      
      <style>{`
        @keyframes scorePopup {
          0% { transform: translateY(0) scale(1); opacity: 1; }
          70% { transform: translateY(-50px) scale(1.3); opacity: 1; }
          100% { transform: translateY(-90px) scale(1.5); opacity: 0; }
        }
      `}</style>
    </div>
  );
};


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<Match3Game />);
  </script>
</body>
</html>
